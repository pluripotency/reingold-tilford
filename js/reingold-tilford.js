// Generated by CoffeeScript 2.5.1
var Node, TreeLayout, TreeNode, apportion, defaultSeparation, executeShifts, hierarchy, moveSubtree, nextAncestor, nextLeft, nextRight, treeRoot;

Node = class Node {
  constructor(data1) {
    this.eachBefore = this.eachBefore.bind(this);
    this.data = data1;
    this.depth = 0;
    this.parent = null;
  }

  eachBefore(callback) {
    var children, i, node, nodes;
    nodes = [this];
    while (node = nodes.pop()) {
      callback(node);
      if (children = node.children) {
        i = children.length - 1;
        while (i >= 0) {
          nodes.push(children[i]);
          --i;
        }
      }
    }
    return this;
  }

};

hierarchy = function(data) {
  var child, children, i, n, node, nodes, root;
  root = new Node(data);
  nodes = [root];
  while (node = nodes.pop()) {
    if ((children = node.data.children) && (n = children.length)) {
      node.children = new Array(n);
      i = n - 1;
      while (i >= 0) {
        nodes.push(child = node.children[i] = new Node(children[i]));
        child.parent = node;
        child.depth = node.depth + 1;
        --i;
      }
    }
  }
  return root;
};

defaultSeparation = function(a, b) {
  if (a.parent === b.parent) {
    return 1;
  } else {
    return 1.5;
  }
};

//radialSeparation = (a, b)-> if a.parent == b.parent then 1/a.depth else 2/a.depth
// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
nextLeft = function(v) {
  if (v.children != null) {
    return v.children[0];
  } else {
    return v.t;
  }
};

// This function works analogously to nextLeft.
nextRight = function(v) {
  if (v.children != null) {
    return v.children[v.children.length - 1];
  } else {
    return v.t;
  }
};

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
moveSubtree = function(wm, wp, shift) {
  var change;
  change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  return wp.m += shift;
};

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
executeShifts = function(v) {
  var change, children, i, results, shift, w;
  shift = 0;
  change = 0;
  children = v.children;
  i = children.length;
  w = void 0;
  results = [];
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    results.push(shift += w.s + (change += w.c));
  }
  return results;
};

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
nextAncestor = function(vim, v, ancestor) {
  if (vim.a.parent === v.parent) {
    return vim.a;
  } else {
    return ancestor;
  }
};

TreeNode = function(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  return this.i = i; // number
};

treeRoot = function(root) {
  var child, children, i, n, node, nodes, tree;
  tree = new TreeNode(root, 0);
  nodes = [tree];
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      i = n - 1;
      while (i >= 0) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
        --i;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
};

TreeNode.prototype.eachAfter = function(callback) {
  var children, i, n, next, node, nodes;
  nodes = [this];
  next = [];
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      i = 0;
      n = children.length;
      while (i < n) {
        nodes.push(children[i]);
        ++i;
      }
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
};

TreeNode.prototype.eachBefore = function(callback) {
  var children, i, node, nodes;
  nodes = [this];
  while (node = nodes.pop()) {
    callback(node);
    if (children = node.children) {
      i = children.length - 1;
      while (i >= 0) {
        nodes.push(children[i]);
        --i;
      }
    }
  }
  return this;
};

apportion = function(v, w, ancestor) {
  var func, separation, shift, sim, sip, som, sop, vim, vip, vom, vop;
  separation = defaultSeparation;
  if (w) {
    vip = v;
    vop = v;
    vim = w;
    vom = vip.parent.children[0];
    sip = vip.m;
    sop = vop.m;
    sim = vim.m;
    som = vom.m;
    shift = null;
    func = function() {
      vom = nextLeft(vom);
      vop = nextRight(vop);
      vop.a = v;
      shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
      if (shift > 0) {
        moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
        sip += shift;
        sop += shift;
      }
      sim += vim.m;
      sip += vip.m;
      som += vom.m;
      sop += vop.m;
    };
    while ((vim = nextRight(vim), vip = nextLeft(vip), vim && vip)) {
      func();
    }
    if (vim && !nextRight(vop)) {
      vop.t = vim;
      vop.m += sim - sop;
    }
    if (vip && !nextLeft(vom)) {
      vom.t = vip;
      vom.m += sip - som;
      ancestor = v;
    }
  }
  return ancestor;
};

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
TreeLayout = class TreeLayout {
  constructor(tree_data) {
    var t;
    // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
    // applied recursively to the children of v, as well as the function
    // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
    // node v is placed to the midpoint of its outermost children.
    this.firstWalk = this.firstWalk.bind(this);
    // Computes all real x-coordinates by summing up the modifiers recursively.
    this.secondWalk = this.secondWalk.bind(this);
    // If a fixed node size is specified, scale x and y.
    this.size = this.size.bind(this);
    this.root = hierarchy(tree_data);
    this.separation = defaultSeparation;
    t = treeRoot(this.root);
    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(this.firstWalk);
    t.parent.m = -t.z;
    t.eachBefore(this.secondWalk);
  }

  firstWalk(v) {
    var children, midpoint, siblings, w;
    children = v.children;
    siblings = v.parent.children;
    w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + this.separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + this.separation(v._, w._);
    }
    return v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  secondWalk(v) {
    v._.x = v.z + v.parent.m;
    return v.m += v.parent.m;
  }

  size(size_x, size_y) {
    var bottom, kx, ky, left, right, s, tx;
    left = this.root;
    right = this.root;
    bottom = this.root;
    this.root.eachBefore(function(node) {
      if (node.x < left.x) {
        left = node;
      }
      if (node.x > right.x) {
        right = node;
      }
      if (node.depth > bottom.depth) {
        return bottom = node;
      }
    });
    s = left === right ? 1 : this.separation(left, right) / 2;
    tx = s - left.x;
    kx = size_x / (right.x + s + tx);
    ky = size_y / (bottom.depth || 1);
    this.root.eachBefore(function(node) {
      node.x = (node.x + tx) * kx;
      return node.y = node.depth * ky;
    });
    return this.root;
  }

};
