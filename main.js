// Generated by CoffeeScript 2.4.1
var Node, TreeLayout, TreeNode, apportion, computeHeight, create_layer_node, defaultSeparation, diag_v, executeShifts, frame, getCurrentCanvas, hierarchy, moveSubtree, nextAncestor, nextLeft, nextRight, rect, ref, resizeHandler, resizeTimer, root, text_svg, textbox, treeRoot, tree_data, tree_layout, userAgent, vm;

computeHeight = function(node) {
  var height, results;
  height = 0;
  node.height = height;
  results = [];
  while ((node.parent != null) && node.height < height) {
    node = node.parent;
    height++;
    results.push(node.height = height);
  }
  return results;
};

Node = class Node {
  constructor(data) {
    this.eachAfter = this.eachAfter.bind(this);
    this.eachBefore = this.eachBefore.bind(this);
    this.data = data;
    this.depth = this.height = 0;
    this.parent = null;
  }

  eachAfter(callback) {
    var children, i, n, next, node, nodes;
    node = this;
    nodes = [node];
    next = [];
    while (node = nodes.pop()) {
      next.push(node);
      children = node.children;
      if (children) {
        i = 0;
        n = children.length;
        while (i < n) {
          nodes.push(children[i]);
          ++i;
        }
      }
    }
    while (node = next.pop()) {
      callback(node);
    }
    return this;
  }

  eachBefore(callback) {
    var children, i, node, nodes;
    node = this;
    nodes = [node];
    children = void 0;
    i = void 0;
    while (node = nodes.pop()) {
      callback(node);
      children = node.children;
      if (children) {
        i = children.length - 1;
        while (i >= 0) {
          nodes.push(children[i]);
          --i;
        }
      }
    }
    return this;
  }

};

hierarchy = function(data, children) {
  var child, childs, i, n, node, nodes, root, valued;
  root = new Node(data);
  valued = +data.value && (root.value = data.value);
  node = void 0;
  nodes = [root];
  child = void 0;
  childs = void 0;
  i = void 0;
  n = void 0;
  while (node = nodes.pop()) {
    if (valued) {
      node.value = +node.data.value;
    }
    if ((childs = node.data.children) && (n = childs.length)) {
      node.children = new Array(n);
      i = n - 1;
      while (i >= 0) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
        --i;
      }
    }
  }
  return root.eachBefore(computeHeight);
};

defaultSeparation = function(a, b) {
  if (a.parent === b.parent) {
    return 1;
  } else {
    return 2;
  }
};

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }
// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
nextLeft = function(v) {
  if (v.children != null) {
    return v.children[0];
  } else {
    return v.t;
  }
};

// This function works analogously to nextLeft.
nextRight = function(v) {
  if (v.children != null) {
    return v.children[v.children.length - 1];
  } else {
    return v.t;
  }
};

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
moveSubtree = function(wm, wp, shift) {
  var change;
  change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  return wp.m += shift;
};

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
executeShifts = function(v) {
  var change, children, i, results, shift, w;
  shift = 0;
  change = 0;
  children = v.children;
  i = children.length;
  w = void 0;
  results = [];
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    results.push(shift += w.s + (change += w.c));
  }
  return results;
};

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
nextAncestor = function(vim, v, ancestor) {
  if (vim.a.parent === v.parent) {
    return vim.a;
  } else {
    return ancestor;
  }
};

TreeNode = function(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  return this.i = i; // number
};

treeRoot = function(root) {
  var child, children, i, n, node, nodes, tree;
  tree = new TreeNode(root, 0);
  node = void 0;
  nodes = [tree];
  child = void 0;
  children = void 0;
  i = void 0;
  n = void 0;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      i = n - 1;
      while (i >= 0) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
        --i;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
};

TreeNode.prototype.eachAfter = function(callback) {
  var children, i, n, next, node, nodes;
  nodes = [this];
  next = [];
  while (node = nodes.pop()) {
    next.push(node);
    children = node.children;
    if (children) {
      i = 0;
      n = children.length;
      while (i < n) {
        nodes.push(children[i]);
        ++i;
      }
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
};

TreeNode.prototype.eachBefore = function(callback) {
  var children, i, node, nodes;
  nodes = [this];
  while (node = nodes.pop()) {
    callback(node);
    children = node.children;
    if (children) {
      i = children.length - 1;
      while (i >= 0) {
        nodes.push(children[i]);
        --i;
      }
    }
  }
  return this;
};

apportion = function(v, w, ancestor) {
  var func, separation, shift, sim, sip, som, sop, vim, vip, vom, vop;
  separation = defaultSeparation;
  if (w) {
    vip = v;
    vop = v;
    vim = w;
    vom = vip.parent.children[0];
    sip = vip.m;
    sop = vop.m;
    sim = vim.m;
    som = vom.m;
    shift = null;
    func = function() {
      vom = nextLeft(vom);
      vop = nextRight(vop);
      vop.a = v;
      shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
      if (shift > 0) {
        moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
        sip += shift;
        sop += shift;
      }
      sim += vim.m;
      sip += vip.m;
      som += vom.m;
      sop += vop.m;
    };
    while ((vim = nextRight(vim), vip = nextLeft(vip), vim && vip)) {
      func();
    }
    if (vim && !nextRight(vop)) {
      vop.t = vim;
      vop.m += sim - sop;
    }
    if (vip && !nextLeft(vom)) {
      vom.t = vip;
      vom.m += sip - som;
      ancestor = v;
    }
  }
  return ancestor;
};

//```
//function apportion(v, w, ancestor) {
//  var separation = defaultSeparation
//  if (w) {
//    var vip = v,
//        vop = v,
//        vim = w,
//        vom = vip.parent.children[0],
//        sip = vip.m,
//        sop = vop.m,
//        sim = vim.m,
//        som = vom.m,
//        shift;
//    while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
//      vom = nextLeft(vom);
//      vop = nextRight(vop);
//      vop.a = v;
//      shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
//      if (shift > 0) {
//        moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
//        sip += shift;
//        sop += shift;
//      }
//      sim += vim.m;
//      sip += vip.m;
//      som += vom.m;
//      sop += vop.m;
//    }
//    if (vim && !nextRight(vop)) {
//      vop.t = vim;
//      vop.m += sim - sop;
//    }
//    if (vip && !nextLeft(vom)) {
//      vom.t = vip;
//      vom.m += sip - som;
//      ancestor = v;
//    }
//  }
//  return ancestor;
//}
//```

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
tree_layout = function() {
  var dx, dy, firstWalk, nodeSize, secondWalk, separation, sizeNode, tree;
  separation = defaultSeparation;
  dx = 1;
  dy = 1;
  nodeSize = null;
  tree = function(root) {
    var bottom, kx, ky, left, right, s, t, tx;
    t = treeRoot(root);
    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk);
    t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    // If a fixed node size is specified, scale x and y.
    if (nodeSize) {
      root.eachBefore(sizeNode);
    } else {
      left = root;
      right = root;
      bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) {
          left = node;
        }
        if (node.x > right.x) {
          right = node;
        }
        if (node.depth > bottom.depth) {
          return bottom = node;
        }
      });
      s = left === right ? 1 : separation(left, right) / 2;
      tx = s - left.x;
      kx = dx / (right.x + s + tx);
      ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        return node.y = node.depth * ky;
      });
    }
    return root;
  };
  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  firstWalk = function(v) {
    var children, midpoint, siblings, w;
    children = v.children;
    siblings = v.parent.children;
    w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    return v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  };
  // Computes all real x-coordinates by summing up the modifiers recursively.
  secondWalk = function(v) {
    v._.x = v.z + v.parent.m;
    return v.m += v.parent.m;
  };
  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  sizeNode = function(node) {
    node.x *= dx;
    return node.y = node.depth * dy;
  };
  tree.separation = function(x) {
    if (arguments.length) {
      separation = x;
      return tree;
    } else {
      return separation;
    }
  };
  tree.size = function(x) {
    if (arguments.length) {
      nodeSize = false;
      dx = +x[0];
      dy = +x[1];
      return tree;
    } else if (nodeSize) {
      return null;
    } else {
      return [dx, dy];
    }
  };
  tree.nodeSize = function(x) {
    if (arguments.length) {
      nodeSize = true;
      dx = +x[0];
      dy = +x[1];
      return tree;
    } else if (nodeSize) {
      return [dx, dy];
    } else {
      return null;
    }
  };
  return tree;
};

frame = function(children, width = 100, height = 60, style = "background-color: cornflowerblue") {
  return m('svg', {
    x: 0,
    y: 0,
    width: width,
    height: height,
    style: style
  }, children);
};

rect = function(x, y, width = 50, height = 20) {
  var x_top, y_top;
  x_top = x - width / 2;
  y_top = y - height / 2;
  return m('rect', {
    rx: 5,
    x: x_top,
    y: y_top,
    width: width,
    height: height,
    stroke: 'white',
    fill: 'darkslategray',
    'stroke-width': 2
  });
};

text_svg = function(x, y, text, style = "font-size: 1em;", anchor = 'middle') {
  return m('text', {
    x: x,
    y: y,
    'text-anchor': anchor,
    'dominant-baseline': 'central',
    fill: 'white',
    style: style
  }, text);
};

textbox = function(x, y, text, width = 50, height = 20) {
  return [rect(x, y, width, height), text_svg(x, y, text)];
};

diag_v = function(start_x, start_y, end_x, end_y, target_height = 20) {
  var first, move_to_start, second, third;
  if (start_y < end_y) {
    start_y = start_y + target_height / 2;
    end_y = end_y - target_height / 2;
  } else {
    start_y = start_y - target_height / 2;
    end_y = end_y + target_height / 2;
  }
  move_to_start = `M${start_x},${start_y}`;
  first = `C${start_x},${(end_y - start_y) / 2 + start_y}`;
  second = `${end_x},${(end_y - start_y) / 2 + start_y}`;
  third = `${end_x},${end_y}`;
  return m('path', {
    d: `${move_to_start} ${first} ${second} ${third}`,
    stroke: 'yellowgreen',
    fill: 'transparent',
    'stroke-width': 1.5
  });
};

tree_data = {
  children: [
    {
      children: [
        {
          children: []
        },
        {
          children: [
            {
              children: []
            },
            {
              children: []
            },
            {
              children: []
            }
          ]
        },
        {
          children: [
            {
              children: []
            },
            {
              children: []
            },
            {
              children: []
            },
            {
              children: []
            },
            {
              children: []
            }
          ]
        },
        {
          children: []
        }
      ]
    },
    {
      children: [
        {
          children: [
            {
              children: []
            },
            {
              children: []
            }
          ]
        }
      ]
    },
    {
      children: [
        {
          children: []
        },
        {
          children: []
        }
      ]
    }
  ]
};

root = hierarchy(tree_data);

getCurrentCanvas = function() {
  var h, mar, w, win_h, win_w;
  mar = [
    0, // top
    0, // left
    0, // right
    4 // bottom
  ];
  //mar = [
  //  10 # top
  //  5 # left
  //  5 # right
  //  10 # bottom
  //]
  win_w = window.innerWidth;
  win_h = window.innerHeight;
  w = win_w - mar[1] - mar[2];
  h = win_h - mar[0] - mar[3];
  return {
    margin: mar,
    win_w: win_w,
    win_h: win_h,
    w: w,
    h: h,
    offset_y: 20
  };
};

resizeTimer = false;

resizeHandler = function() {
  if (resizeTimer !== false) {
    clearTimeout(resizeTimer);
  }
  return resizeTimer = setTimeout(function() {
    m.startComputation();
    vm.create();
    return m.endComputation();
  }, 500);
};

if (((ref = window.navigator) != null ? ref.userAgent : void 0) != null) {
  userAgent = window.navigator.userAgent;
  if (userAgent.indexOf('iPhone') >= 0 || userAgent.indexOf('iPad') >= 0 || userAgent.indexOf('android') >= 0) {
    window.addEventListener('orientationchange', resizeHandler);
  } else {
    window.addEventListener('resize', resizeHandler);
  }
}

create_layer_node = function(node, node_list, name, offset_y) {
  var len;
  node_list.push(textbox(node.x, node.y + offset_y, name));
  len = node_list.length;
  if (node.children != null) {
    return node.children.map(function(child, i) {
      node_list.push(diag_v(node.x, node.y + offset_y, child.x, child.y + offset_y));
      return create_layer_node(child, node_list, len + i, offset_y);
    });
  }
};

vm = {
  create: function() {
    var canvas, created, h, node_list, off_y, w;
    canvas = getCurrentCanvas();
    w = canvas.w;
    h = canvas.h;
    off_y = canvas.offset_y;
    created = tree_layout().size([w, h - off_y * 2])(root);
    node_list = [text_svg(10, 20, 'Reingold Tilford Tree Layout', 'font-size: 1.2em;', null)];
    create_layer_node(created, node_list, 1, off_y);
    return frame(node_list, w, h);
  }
};

TreeLayout = {
  controller: function(args) {
    return vm;
  },
  view: function(ctrl, args) {
    return m('div', ctrl.create());
  }
};

m.mount(document.getElementById('contents'), m.component(TreeLayout));
